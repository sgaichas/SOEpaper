---
title: "State of the Ecosystem: So What? Improving ecosystem reporting for fisheries managers in the Northeast US"
author:
- name: Sarah K. Gaichas*, Sean Hardison, Sean Lucey, Scott Large  
  affiliation: NOAA NMFS Northeast Fisheries Science Center, Woods Hole, MA, USA
- name: everyone else
  affiliation: placeholder, USA
date: '`r format(Sys.Date(), "%B %d, %Y")`'
abstract: Understanding the context of ecosystem status and trends is important for making informed natural resource management decisions. However, many fishery management systems are fully occupied with decisions at the species or stock level, and busy managers are reluctant to consider extensive reports with unfamiliar information if the connection to current management decisions and objectives are unclear. Here, we describe the process used to develop streamlined ecosystem reporting to meet management needs in two US fishery management regions, New England and the Mid-Atlantic. A multi-disciplinary team was assembled to revise an initial report that had been based on a format used in another US region. First, ecosystem indicators were clearly aligned with stated fishery management objectives. Second, objectives and associated indicators relating to human well-being (e.g., seafood production) were placed first in the report, rather than last. Third, standardized visualizations were used for time series and maps. Finally, reports used transparent and reproducible production methods to meet management deadlines. Engagement with managers is ongoing to further improve the utility of the report. This approach to streamlined, audience-specific ecosystem reporting is flexible and adaptable to many different governance contexts, and can be used to provide information essential to implement ecosystem based management.  
keywords: ecosystem approach, natural resource management, fisheries, integrated ecosystem assessment, ecosystem indicators, economic indicators, management objectives
output:
  pdf_document:
    includes:
      in_header: riskassess-preamble-latex.tex
    keep_tex: yes
    toc: no
    template: svm-latex-ms.tex
  html_document:
    toc: yes
  word_document:
    toc: no
fontsize: 11pt
geometry: margin=0.8in
csl: frontiers.csl
bibliography: SOE.bib
---

*add names from SOE acknowledgements:*
*- name: Donald Anderson, Amani Bassyouni, Lisa Calvo, Lisa Colburn, Geret DePiper, Deb Duarte, Kevin Friedland, Heather Haas, Mike Hammil, Kimberly Hyde, Loren Kellogg, Kristin Kleisner, Dave Kulis, Chris Melrose, Ryan Morse, Kimberly Murray, Chris Orphanides, Charles Perretti, Karl Roscher, Vincent Saba, Laurel Smith, Mark Terceiro, John Walden, Harvey Walsh, Mark Wuenschel*
*add Mike Fogarty and graphic artist for conceptual models*
*affiliation: NEFSC and other places, need to sort out, USA*


```{r Directory and Data Set-up, echo=F, message=F, warning=FALSE, paged.print=TRUE}

 data.dir  <- './data'
 image.dir <- './images'
 gis.dir <- './usa_shape_files'

#STOP HERE
#Do you have the most updated version of the SOE.data.2018 dataset AND the necessary spatial data? Check the SOE_MAB google drive for most recent version.


load(file.path(data.dir, "SOE_data_2018.Rdata"))
# latex figure folder
knitr::opts_chunk$set(echo = FALSE, fig.path = './iea_figs_ne/')

#The map_figs option can be set to FALSE to skip making maps on the fly (they will be missing). Or TRUE to make them. 
map_figs <- T

```

```{r libraries, echo=F, message=F, warning=FALSE, paged.print=TRUE, results = 'hide'}
library(Kendall);library(data.table);library(zoo)
library(dplyr);library(nlme);library(AICcmodavg)
library(colorRamps);library(Hmisc);library(rgdal)
library(maps);library(mapdata);library(raster)
library(grid);library(stringr);library(png)
library(ncdf4);library(marmap); library(magick);
library(knitr)


#get map data and set constants
#projection
map.crs <- CRS("+proj=longlat +lat_1=35 +lat_2=45 +lat_0=40 +lon_0=-77 +x_0=0
               +y_0=0 +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0")

#coastline and bathymetry
coast <- readOGR(gis.dir, 'NES_LME_coast', verbose = F)
coast <- spTransform(coast,map.crs)
bathy <- raster('NES_bathymetry.tif')

#define extents for cropping
e  <- extent(-77.2, -64.2, 35, 48)
th_extent <-extent(-77,-65,35,45) #thermal habitat

#crop - thermal habitat bathymetry before general bathymetry
coast <- crop(coast, e)
th <- crop(bathy,th_extent)
bathy <- crop(bathy, e)

#projections
projection(th) <- map.crs
projection(bathy) <- map.crs

#get strata files to clip thermal habitat projections
strata <- readOGR(gis.dir,"strata", verbose = F)
strata@proj4string <- map.crs
```


```{r libraries and functions, include=F, echo = F}
options(repos = c(CRAN = "http://cran.rstudio.com"))


fit_lm <- function(dat) {
  # Remove missing values first so that all models
  # use the same number of observations (important for AIC)
  # dat <- dat %>% dplyr::filter(complete.cases(.))
  
  # Constant model (null model used to calculate 
  # overall p-value)
  constant_norm <-
    nlme::gls(series ~ 1, 
              data = dat)
  
  constant_ar1 <-
    try(nlme::gls(series ~ 1,
                  data = dat,
                  correlation = nlme::corAR1(form = ~time)))
  if (class(constant_ar1) == "try-error"){
    return(best_lm <- data.frame(model = NA,
                                 aicc  = NA,
                                 coefs..Intercept = NA,
                                 coefs.time = NA,
                                 coefs.time2 = NA,
                                 pval = NA)) 
  } 
  
  
  
  # Linear model with normal error
  linear_norm <- 
    nlme::gls(series ~ time, 
              data = dat)
  
  # Linear model with AR1 error
  linear_ar1 <- 
    try(nlme::gls(series ~ time, 
                  data = dat,
                  correlation = nlme::corAR1(form = ~time)))
  if (class(linear_ar1) == "try-error"){
    return(best_lm <- data.frame(model = NA,
                                 aicc  = NA,
                                 coefs..Intercept = NA,
                                 coefs.time = NA,
                                 coefs.time2 = NA,
                                 pval = NA))
    
  }
  
  # Polynomial model with normal error
  dat$time2 <- dat$time^2
  poly_norm <- 
    nlme::gls(series ~ time + time2, 
              data = dat)
  
  # Polynomial model with AR1 error
  poly_ar1 <- 
    try(nlme::gls(series ~ time + time2, 
                  data = dat,
                  correlation = nlme::corAR1(form = ~time)))
  if (class(poly_ar1) == "try-error"){
    return(best_lm <- data.frame(model = NA,
                                 aicc  = NA,
                                 coefs..Intercept = NA,
                                 coefs.time = NA,
                                 coefs.time2 = NA,
                                 pval = NA))
    
  }
  
  # Calculate AICs for all models
  df_aicc <-
    data.frame(model = c("poly_norm",
                         "poly_ar1",
                         "linear_norm",
                         "linear_ar1"),
               aicc  = c(AICc(poly_norm),
                         AICc(poly_ar1),
                         AICc(linear_norm),
                         AICc(linear_ar1)),
               coefs = rbind(coef(poly_norm),
                             coef(poly_ar1),
                             c(coef(linear_norm), NA),
                             c(coef(linear_ar1),  NA)),
               # Calculate overall signifiance (need to use
               # ML not REML for this)
               pval = c(anova(update(constant_norm, method = "ML"),
                              update(poly_norm, method = "ML"))$`p-value`[2],
                        anova(update(constant_ar1, method = "ML"),
                              update(poly_ar1, method = "ML"))$`p-value`[2],
                        anova(update(constant_norm, method = "ML"),
                              update(linear_norm, method = "ML"))$`p-value`[2],
                        anova(update(constant_ar1, method = "ML"),
                              update(linear_ar1, method = "ML"))$`p-value`[2]))
  
  best_lm <-
    df_aicc %>%
    dplyr::filter(aicc == min(aicc))
  
  
  if (best_lm$model == "poly_norm") {
    model <- poly_norm
  } else if (best_lm$model == "poly_ar1") {
    model <- poly_ar1
  } else if (best_lm$model == "linear_norm") {
    model <- linear_norm
  } else if (best_lm$model == "linear_ar1") {
    model <- linear_ar1
  }
  
  return(list(p = best_lm$pval,
              model = model))
}


#Plot new figure - Set end.start to 10 years before end of time series

soe.plot <- function(data, x.var, y.var, x.label = '', y.label = '', tol = 0.1,
                     x.start = NA, x.end = NA, end.start = 2008, bg.col = background, mean_line = T,
                     end.col = recent, stacked = NA, x.line = 2.5, y.line = 3.5, scale.axis = 1,
                     rel.y.num = 1.5, rel.y.text = 1.5, suppressAxis = FALSE,status  = F,anomaly = F,
                     endshade = TRUE, full.trend = TRUE, point.cex = 1.5, lwd = 2, ymax = TRUE,ymin = TRUE,
                     y.upper = y.upper, y.lower = y.lower, extra = FALSE, x.var2 = x.var2, y.var2 = y.var2,
                     line.forward = FALSE, mean_line.2 = T, cex.stacked = 1) {
  
  #print("You'll need to remove or interpolate NA values before this function will work")
  
  #Select Data
  x <- data[Var == y.var, ]
  x <- x[order(x[, get(x.var)]), ]
  setnames(x, x.var, 'X')
  
  #Set common time step if necessary
  if(is.na(x.start)) x.start <- min(x[, X])
  if(is.na(x.end))   x.end   <- max(x[, X])
  x <- x[X >= x.start, ]
  
  #Set up plot parameters
  if (ymax == TRUE){
    y.max <- max(x[, Value]) + tol * max(x[, Value])
  } else {
    y.max <- as.numeric(y.upper)
  }
  
  if (ymin == TRUE){
    y.min <- min(x[, Value]) - tol * abs(min(x[, Value]))
  } else if (ymin == FALSE){
    y.min <- as.numeric(y.lower)
  }
  
  y.mean <- mean(x[, Value])
  y.sd <- sd(x[, Value])
  
  #Plot blank plot
  plot(x[X >= x.start, list(X, Var)], xlim = c(x.start, x.end),
       ylim = c(y.min,y.max), xlab = '', ylab = '', axes = F, ty = 'n')


  #Add background
  u <- par('usr')
  rect(u[1], u[3], u[2], u[4], border = NA, col = bg.col)
  
  #Add end period shading
  if (endshade == TRUE){
    rect(end.start - 0.5, u[3], u[2], u[4], border = NA, col = end.col)
  }
  
  #Add mean line
  if (anomaly == F){
      if (mean_line == TRUE){
      abline(h = y.mean, col = 'grey', lwd = 3, lty = 2)
      } 
  } else if (anomaly == TRUE){
      abline(h = 0, col = 'grey', lwd = 3, lty = 2)
  }
  
  #Add x y lines
  abline(h = u[3], lwd=3)
  abline(v = u[1], lwd=3)
  
  #Add data points/lines
  points(x[, list(X, Value)], pch = 16, cex = point.cex)
  lines( x[, list(X, Value)], lwd = lwd)
  
  #extra lines
  if (extra == TRUE){
    x2 <- data[Var == y.var2, ]
    x2 <- x2[order(x2[, get(x.var2)]), ]
    setnames(x2, x.var2, 'X2')
    x2 <- x2[X2 >= x.start, ]
    if (mean_line.2 == TRUE){
     abline(h = mean(x2[, Value]), col = 'lightcoral', lwd = 3, lty = 2) 
    }
    points(x2[, list(X2, Value)], pch = 16, cex = point.cex, col = "indianred")
    lines( x2[, list(X2, Value)], lwd = lwd, col = "indianred")
    }
    
  
  #Add axis
  if (suppressAxis == FALSE){
    if(is.na(stacked)) axis(1, cex.axis = 1)
    if(!is.na(stacked)){
      if(stacked!= 'A') axis(3, cex.axis = 1.5, tck = 0.1, labels = F)
    }
  }

  #Stacked axes with 0 overlap so need to remove
  labels <- round((axTicks(2) / scale.axis), 5)
  if(labels[1] == 0) labels[1] <- ''
  axis(2, at = axTicks(2), labels = labels, cex.axis = rel.y.num,
       las = T)

    #Add axis labels
    if(!is.na(stacked)) text(u[1], u[4], labels = stacked, cex = cex.stacked, adj = c(-0.5, 1.5))
    if(is.na(stacked)){
      mtext(1, text = x.label, line = x.line, cex = 1)
      mtext(2, text = y.label, line = y.line, cex = rel.y.text)
    }
  
    if (full.trend == T){
    #Split data into past decade and full time series
    dat <- as.data.frame(x[, list(X, Value)])
    
    dat <- dat %>% dplyr::rename(series = Value) %>%
      mutate(time = seq(1,nrow(dat),1))
    
    # Fit linear model
    lm_out <- fit_lm(dat = dat)
    p <- lm_out$p
    if (p < .05){
        
      newtime <- seq(min(dat$time), max(dat$time), length.out=length(dat$time))
      newdata <- data.frame(time = newtime,
                      time2 = newtime^2)
      lm_pred <- AICcmodavg::predictSE(lm_out$model, 
                                 newdata = newdata,
                                 se.fit = TRUE)
      
      year <- seq(x$X[1],x$X[length(x$X)],length.out = length(dat$time))

      # Make plot
      if (lm_pred$fit[length(lm_pred$fit)] > lm_pred$fit[1]){
        lines(year, lm_pred$fit, col = main.pos, lwd = 7)
        points(x[, list(X, Value)], pch = 16, cex = point.cex)
        lines( x[, list(X, Value)], lwd = lwd)

        if (line.forward == TRUE){
           lines(year, lm_pred$fit, col = main.pos, lwd = 7)
        }
      } else if (lm_pred$fit[length(lm_pred$fit)] < lm_pred$fit[1]){
        lines(year, lm_pred$fit, col = main.neg, lwd = 7)
        points(x[, list(X, Value)], pch = 16, cex = point.cex)
        lines( x[, list(X, Value)], lwd = lwd)
        if (line.forward == TRUE){
           lines(year, lm_pred$fit, col = main.neg, lwd = 7)
        }
      }
    }
    
    if (extra == TRUE){
      
      # Second variable
      dat <- as.data.frame(x2[, list(X2, Value)])
    
      dat <- dat %>% dplyr::rename(series = Value) %>%
      mutate(time = seq(1,nrow(dat),1))
    
     # Fit linear model
      lm_out <- fit_lm(dat = dat)
      p <- lm_out$p
      points(x2[, list(X2, Value)], pch = 16, cex = point.cex, col = "indianred")
      lines( x2[, list(X2, Value)], lwd = lwd, col = "indianred")
      if (p < .05){
    
        newtime <- seq(min(dat$time), max(dat$time), length.out=length(dat$time))
        newdata <- data.frame(time = newtime,
                      time2 = newtime^2)
        lm_pred <- AICcmodavg::predictSE(lm_out$model, 
                                 newdata = newdata,
                                 se.fit = TRUE)
        
        year <- seq(x2$X2[1],x2$X2[length(x2$X2)],length.out =length(dat$time))
   
    # Make plot
        if (lm_pred$fit[length(lm_pred$fit)] > lm_pred$fit[1] ){
          lines(year, lm_pred$fit, col = main.pos, lwd = 7)
          points(x2[, list(X2, Value)], pch = 16, cex = point.cex, col = "indianred")
          lines( x2[, list(X2, Value)], lwd = lwd, col = "indianred")
        } else if (lm_pred$fit[length(lm_pred$fit)] < lm_pred$fit[1]){
          lines(year, lm_pred$fit, col = main.neg, lwd = 7)
          points(x2[, list(X2, Value)], pch = 16, cex = point.cex, col = "indianred")
          lines( x2[, list(X2, Value)], lwd = lwd, col = "indianred")
        } 
     }
    }

  }


 
}  


#Add axis labels for stacked plots
soe.stacked.axis <- function(x.label, y.label, x.line = 2.5,rel.x.text = 1.5,
                             y.line = 3.5, rel.y.text = 1.5, outer = TRUE){
  axis(1, cex.axis = rel.x.text)
  mtext(1, text = x.label, line = x.line, cex = rel.x.text, outer = outer)
  mtext(2, text = y.label, line = y.line, cex = rel.y.text, outer = outer)
  
}


#Background colors
background   <- 'white'
recent       <- '#E6E6E6'
main.pos <- rgb(253/255, 184/255, 99/255,  alpha = .9)
main.neg <- rgb(178/255, 171/255, 210/255, alpha = .9)

#Finder function for quickly finding variables based on partial match
finder <- function(data, match = match, factor = T){
  found <- unique(data[grepl(match,data$Var),]$Var)
  if (factor == T){
    return(found)
  } else {
    return(as.character(found))
  }
  
}

#thermal habitat map function
#thermal habitat map function
th_plot <- function(data, letter, z.max, y.axis = T,
                    legend = T, pos){
  if (pos == 'topleft'){
    par(mar=c(3.9, 2.8,3.5,0), mex = .3,  mgp = c(4, .35, 0))
  } else if (pos == 'topright'){
    par(mar=c(3.9, 0, 3.5, 2.8), mex = .3,  mgp = c(4, .35, 0))
  } else if (pos == "bottomleft"){
    par(mar=c(3.9,2.8,3.5,0), mex = .3,  mgp = c(4, .35, 0))
  } else if (pos == "bottomright"){
    par(mar=c(3.9, 0, 3.5, 2.8), mex = .3,  mgp = c(4, .35, 0))
  }
  
  data <- nc_open(data)
  
  #longitude
  lon <- ncvar_get(data, "xi", verbose = F)
  
  #latitude
  lat <- ncvar_get(data, "yi", verbose = F)
  
  #thermal habitat projection
  z <- ncvar_get(data, "zi")
  
  #combine in data.frame
  proj <- data.frame(lon = lon,
                     lat = lat,
                     z = z)
  
  proj <- proj %>% filter(z != "NA",z>0) %>% 
    mutate(z = plyr::mapvalues(z, from = (z[(z>z.max)]), to = rep(z.max,length(z[(z>z.max)]))))
  
  #turn dataframe to raster
  coordinates(proj) = ~lon+lat
  proj4string(proj)=map.crs # set it to lat-long
  proj = spTransform(proj,map.crs)
  proj <- proj[strata,]
  gridded(proj) = TRUE
  r = raster(proj)
  projection(r) = map.crs
  
  colors <- matlab.like(120)
  #plot maps
  if (legend == T){
    plot(r, col=colors, ylim=c(35,45),
         breaks=seq(0,z.max,length.out=length(colors)),
         zlim = c(0,z.max),
         legend.width = 2,
         axes=F, interpolate = T, las = 1,box = T,
         axis.args=list(at=seq(0, z.max, length.out = 5),
                        labels=round(seq(0,1,length.out = 5),1), 
                        cex.axis=0.8),
         legend.args=list(text=expression(paste("     Thermal \n      Habitat")),
                          side=3, font=2, line=1, cex=.65))
  } else {
    plot(r, col=colors, ylim=c(35,45),
         breaks=seq(0,z.max,length.out=length(colors)),
         axes=F, interpolate = F, las = 1,box = T,legend = F)
  }
  
  
  map("worldHires", xlim=c(-77,-65),ylim=c(35,45), fill=T,border=0,col="gray", add = T)
  
  if (y.axis == T){
    map.axes(cex.axis = .7)
  } else if (y.axis == F){
    axis(1,cex = .7)
    box(lty = 'solid', col = 'black',lwd = 1)
  }
  
  
  contour(th,drawlabels = F,nlevels = 2,add=T, col = "gray20",lty=2, lwd = .5)
  text(-75.5, 43.9, letter,cex = 1.5)
  
}


```


# Introduction
As national and international policy increasingly calls for ecosystem-based management of natural resources, it is important for decision-makers to understand the current status and recent trends of key ecosystem attributes. For example, an ecosystem in a high productivity state may withstand extractive activities better than the same ecosystem in a low productivity state. 

* EBFM sounds hard but it doesnt have to be, here is an example of ecosystem reporting that is useful to managers and how we did it.  Initial drafts followed a format used in another region but managers wanted to know "so what". Here is how we addressed this to produce two relatively automated reports that Councils are now requesting annually. lessons learned could serve as example for other ecosystem reporting efforts.

# Methods
* build on existing efforts inside and outside the region; ESRs, SOE west coast
* address OBJECTIVES, clearly align indicators with objectives (IEA process, WGNARS)
* conceptual model links environmental drivers, ecosystem components, human activities, and objectives
* put most manager-relevant things first: HUMAN DIMENSIONS instead of salinity, etc
* keep it short, <25 printed pages
* keep language non-technical, don't include references etc in report
* publish technical methods separately for those that are interested (see [supplement](https://noaa-edab.github.io/tech-memo/); Technical methods as individual rmarkdown documents rolled up into one bookdown.)
produce in Rmarkdown for reproducibility and ease of conversion to different reports
* data in standardized format with standardized plotting
* version control on github
* production process: first years, one lead asking for data from multiple people, inefficient. 2017: workshop to develop outline in August with managers to focus further, smaller working groups (human dimensions, protected species, etc) developing new section until December, when data were needed. Mid-January 2018 synthesis meeting, report production Feb, internal review, revision, and to initial Council review early March 2018.
present to the Council SSC (Mid) first for initial review, turn around for full Council presentation in ~1 month responding as possible to review, responding to previous year's comments explicitly
Councils receive reports in April of each year, main message is whether there are big changes in the ecosystem or other threats to achieving their objectives

# Results
The results of this process were the full [Mid-Atlantic State of the Ecosystem 2018](http://www.mafmc.org/s/Tab04_State-of-the-Ecosystem-Apr2018.pdf) and
[New England State of the Ecosystem 2018](https://s3.amazonaws.com/nefmc.org/2_Ecosystem-Status-Report.pdf) reports delivered in April 2018, which are posted as part of the public record on each Fishery Management Council's website. Here, we highlight key aspects and findings of the reports that arose from the multidiscplinary approach. 

## Objectives aligned with indicators

Table \ref{obj_cats_MAB}

## Place-based spatial units

Figure \ref{map}

## Conceptual models

Figure \ref{conceptual}

## Human dimensions first

## Synthesis across indicators

# Discussion
* Rising to the "so what" challenge improved ecosystem reporting in the NE US and has resulted in other analyses of use to managers (e.g. ref risk assessment, hopefully published by then). An effective annual process has evolved where contextual information is presented that can change multiple decisions if necessary (ref Zador, value of qualitative information). Flexibility and responsiveness to audience important, willing to change reporting as manager needs change.
* Focus on synthesis and indicators directly addressing management objectives key. Don't get rid of all other ecosystem indicators but report selectively from a "mothership" of ecosystem data (e.g. ESR on the web) for different audiences. The encyclopedic report is less useful for managers who have limited time and need the bottom line. Oceanographers want the salinity time series, fishery managers dont know what to do with them unless clearly connected to habitat of managed species or other objectives.
* Put best practices/lessons learned from IEA group WGNARS (ref DePiper et al 2017, also Levin et al 2009 other IEA lit) into actual practice.
* Automation and transparency useful not just in theory but for practical report production. Rmarkdown and github workflow efficient and traceable, allows effective collaboration. (Would be great to have SOE as html for website too and point to that)
* Next steps (in progress): web access to indicator data through ERDDAP (link), retrospective documentation of past indicators, development of new indicators. Priority given to indicator selection and evaluation, threshold analysis, synthetic methods such as DFA. Keep indicator data available and accessible for synthesis, modeling, future work.
* Process flexible and can be adjusted to needs in any region/management context. Maybe EBFM isn't so hard after all.

# References
<div id="refs"></div>

# Figures

```{r map, fig.cap="Mid Atlantic Bight (MAB) spatial extent \\label{map}", fig.height=6, fig.width=4, out.width='0.8\\linewidth', fig.align='center', echo = F, message = FALSE, warning = FALSE, eval = T}
image_read(file.path(image.dir,"NEshelfEcoRegionsALL.png")) %>%
image_trim()

```

\newpage

```{r conceptual, fig.cap="Mid-Atlantic Ecosystem \\label{conceptual}", fig.height=6, fig.width=4, out.width='\\linewidth', fig.align='center', echo = F, message = FALSE, warning = FALSE, eval = T,fig.pos='H'}
knitr::include_graphics(file.path(image.dir, 'SOE_MAB_ConceptMod.png'))

```

\newpage

# Tables

**Table 1**: Mid-Atlantic ecosystem objectives
```{r obj_cats_MAB, echo=FALSE, message=FALSE, warnings=FALSE, results='asis'}
tabl <- "
| Objective Categories     | Indicators reported here                                  |
|:-------------------------|:----------------------------------------------------------|
| Seafood production       | Landings by feeding guild, mariculture                    |
| Profits                  | Revenue by feeding guild                                  |
| Recreation               | Number of anglers and trips; recreational catch           |
| Stability                | Diversity indices (fishery and species)                   |
| Social-Cultural          | Commercial and recreational reliance; social vulnerability|
| Biomass                  | Biomass or abundance by feeding guild from surveys        |
| Productivity             | Condition and recruitment of MAFMC managed species        |
| Trophic structure        | Relative biomass of feeding guilds, primary productivity  |
| Habitat                  | Thermal habitat projections, estimated habitat occurrence |
"
cat(tabl) # output the table in a format good for HTML/PDF/docx conversion
```

\newpage



